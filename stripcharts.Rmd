---
title: "Introduction to R"
author: "Maria Doyle"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_notebook:
    toc: yes
    toc_float: yes
    toc_depth: 4
subtitle: visualising RNA-seq data with stripcharts
---

#### Acknowledgements
Material created by Peter Mac Data Science.

## Objectives
  
* Demonstrate how to create stripcharts with ggplot2's `geom_jitter()`
* Demonstrate the use of faceting to create multiple plots based on a column
* Demonstrate using tidyr's `gather()` to convert from wide to long (tidy) format
* Demonstrate dplyr's `select()` to choose columns and `filter()` to choose rows
* Demonstrate use of dplyr's `case_when()` instead of multiple `ifelse()`s
* Demonstrate the powerful pipe `%>%`


## Introduction

In this tutorial, we will learn some R through creating stripcharts to visualise results from an RNA-seq experiment.

### RNA-seq dataset

We will again use the published RNA-seq data from the Nature Cell Biology paper by [Fu et al. 2015](https://www.ncbi.nlm.nih.gov/pubmed/25730472). This study examined expression in basal and luminal cells from mice at different stages (virgin, pregnant and lactating).

Here we will work with the normalised counts for all 12 samples.
![](images/mouse_exp.png)

First we will load in the libraries we need. These are already installed for you but if you need to install it on your own computer you can use `install.packages('tidyverse')`. 

```{r}
library(tidyverse)
```

```{r results = 'hide'}
norm_counts <- read_tsv("/training/r-intro-tidyverse/data/limma-voom_normalised_counts.tsv.gz")
```

Let's take a look at the `norm_counts` data.

How many rows and columns are in the normalised counts file (`norm_counts`)?

## Stripcharts of multiple genes

We can make stripcharts to view the expression of multiple genes. Let's plot the expression of the top 10 differentially expressed genes in luminal cells from the pregnant mice versus the luminal cells from the lactating mice. In the volcano plot tutorial we showed how to get these top 10 gene symbols. Here we will show how to create an object with the symbols manually. Remember, in R we use `c()` to combine multiple values.

```{r}
top10_syms <- c("Csn1s2b", "Slc25a1", "Slc34a2", "Atp2b2", "Acacb", "Slc30a2", "Elovl5", "Egf", "Ceacam10", "Pmvk")
```

Then we extract the normalised counts information for these genes from the `norm_counts` file.

## Filtering rows with `filter()`

We can use dplyr's `filter()` to filter rows. Let's take a look at how `filter()` works. 

To use `filter()` we specify the data and the column(s) we want to use to filter with our criteria. 

If we wanted to filter for rows (genes) in the MCL1.DG sample that have expression above a threshold (e.g. 5) we would write below.
```{r}
filter(norm_counts, MCL1.DG > 5)
```

If we wanted to filter for genes that have an expression value above 5 in both the basal virgin samples (MCL1.DG and MCL1.DH) we specify both columns and the criteria. Note that we need to specify the threshold for each column e.g `MCL1.DG > 5 & MCL1.DH > 5` and not `MCL1.DG & MCL1.DH > 5`.
```{r}
filter(norm_counts, MCL1.DG > 5 & MCL1.DH > 5)
```


To filter this dataset for the rows that contain the Csn1s2b gene we would write below. Note that we use a `==` when we want to test if a value matches exactly.
```{r}
filter(norm_counts, SYMBOL == "Csn1s2b")
```
If we wanted to filter for 2 genes we could write that as below. Here we use "|" which means or as we want the row if the SYMBOL column contains Csn1s2b or Slc25a1.

```{r}
filter(norm_counts, SYMBOL == "Csn1s2b" | SYMBOL == "Slc25a1")
```

If we want to filter the rows for our top 10 genes. We use `SYMBOL %in% top10_syms` which means we want all the rows where the SYMBOL column contains one of the gene symbols in `top10_syms`. Remember, in R we use `%in%` to test if a value is in a set of values.

```{r}
top10_counts <- filter(norm_counts, SYMBOL %in% top10_syms)
```

Take a look.

```{r}
top10_counts
```

## Selecting columns with `select()`

We don't need the ENTREZID and GENENAME columns, we are only going to use the SYMBOL column and the counts so we can use `select()` to remove these columns.

`filter()` is used to choose rows, to choose columns we use `select()`. Let's take a look at how `select()` works.

If we wanted to select the gene symbol column we would write below.

```{r}
select(top10_counts, SYMBOL)
```

If we wanted the SYMBOL column and the MCL1.DG sample column we would write below.

```{r}
select(top10_counts, SYMBOL, MCL1.DG)
```

See the select help (?select) as there are also useful helper functions you can use inside `select()`, such as `contains()`, `starts_with()` and `ends_with()`.

We can also `select()` to remove columns by specifying a "-"" before the column name(s).

Let's remove the ENTREZID and GENENAME columns so we only keep the SYMBOL column and the sample expression values.

```{r}
top10_counts <- select(top10_counts, -ENTREZID, -GENENAME)
top10_counts
```

## Converting wide into tidy format with `gather()`

To more easily plot with ggplot2 we need to change the data into ["tidy data"](https://en.wikipedia.org/wiki/Tidy_data). There are 3 rules of tidy data:

  1. Each variable must have its own column.
  2. Each observation must have its own row.
  3. Each value must have its own cell. 
  
In our expression table there should be just one column for all expression values instead of multiple columns. We can use tidyr's `gather()` to easily change the format.

The SYMBOL information is already in a column so we use "-" to say leave that column alone. Then gather will reformat *all the other columns* (the expression values) into two columns "key" and "value". The "key" column will contain the column names (our sample ids), and the "value" column will contain the values from the columns (our expression values). We will give the key column the name "Sample" and the value column the name "Norm_counts".

```{r}
# change to tidy data format (all expression values in one column)
top10_counts <- gather(top10_counts, key = Sample, value = Norm_counts, -SYMBOL)
```

Take a look.
```{r}
top10_counts
```

Take a closer look with `View()`
```{r eval=FALSE}
View(top10_counts)
```

## Testing multiple conditions with `case_when()`

We want to plot and compare the expression in the groups, so we use `mutate()`to add a column called "Group" to say what group each sample belongs to.  Here we use dplyr's `case_when()` to say if the same id matches are conditions then add the appropriate group name into the Group column. We could use `ifelse()` as we did in the volcano plot tutorial. However, when there are many conditions to test, as there are here, `case_when()` is easier to use.

```{r}
top10_counts <- mutate(top10_counts, Group=case_when(
        Sample %in% c("MCL1.DG", "MCL1.DH")  ~ "basal virgin",
        Sample %in% c("MCL1.DI", "MCL1.DJ")  ~ "basal pregnant",
        Sample %in% c("MCL1.DK", "MCL1.DL")  ~ "basal lactate",
        Sample %in% c("MCL1.LA", "MCL1.LB")  ~ "luminal virgin",
        Sample %in% c("MCL1.LC", "MCL1.LD")  ~ "luminal pregnant",
        Sample %in% c("MCL1.LE", "MCL1.LF")  ~ "luminal lactate"
       ))
```

Take a look at the data again with `View()`
```{r}
View(top10_counts)
```

## Creating stripcharts with `geom_jitter()`

Now we can make a stripchart. We plot the Group on the X axis and the Norm_counts on the y axis. We will use `+ geom_jitter()` to create a jitter plot. A jitter plot is similar to a scatter plot but adds a small amount of random variation to the location of each point so they don't overlap. Why do we not just use a scatter plot? Let's take a look. 

```{r}
ggplot(top10_counts, aes(x=Group, y=Norm_counts)) +
  geom_point()
```

Some of the points are overlapping so we use `geom_jitter()` to avoid having overlapping points.

```{r}
ggplot(top10_counts, aes(x=Group, y=Norm_counts)) +
  geom_jitter()
```

## Creating stripcharts for each gene with `facet_wrap()`

The points are no longer overlapping, however, this is all the genes in one plot. We would like to see the values for each gene so we add ` + facet_wrap(~SYMBOL)` to say we want to a plot for each gene (the SYMBOL column). 

```{r}
ggplot(top10_counts, aes(x=Group, y=Norm_counts)) +
  geom_jitter() +
  facet_wrap(~SYMBOL)
```

We can change the number of rows (`nrows`) or columns (`ncols`) to balance the plot. Let's try 2 rows (`nrow=2`).

```{r}
ggplot(top10_counts, aes(x=Group, y=Norm_counts)) +
  geom_jitter() +
  facet_wrap(~SYMBOL, nrow=2)
```


We can add `col=Group` to say we want to colour by the groups (the Group column we added).

```{r}
ggplot(top10_counts, aes(x=Group, y=Norm_counts, col=Group)) +
  geom_jitter() +
  facet_wrap(~SYMBOL, nrow=2)
```

We can add `+ theme(axis.text.x = element_text(angle = 90)` to make the x axis labels vertical so they don't overlap.

```{r}
ggplot(top10_counts, aes(x=Group, y=Norm_counts, col=Group)) +
  geom_jitter() +
  facet_wrap(~SYMBOL, nrow=2) +
  theme(axis.text.x = element_text(angle = 90)) 
```

## Ordering categories along an axis

The groups have been plotted in alphabetical order on the x axis, however, we may want to change the order. We may prefer to plot the groups in order of stage, for example, basal virgin, basal pregnant, basal lactate, luminal virgin, luminal pregnant, luminal lactate. In the volcano plot tutorial we showed how to change the order of items in the legend with `breaks=` into the scale layer. Let's try that here.

First let's make an object with the group order that we want.
```{r}
group_order <- c("basal virgin", "basal pregnant", "basal lactate", "luminal virgin", "luminal pregnant", "luminal lactate")
```

Then let's add this `group_order` into `breaks=`.

```{r}
ggplot(top10_counts, aes(x=Group, y=Norm_counts, col=Group)) +
  geom_jitter() +
  facet_wrap(~SYMBOL, nrow=2) +
  theme(axis.text.x = element_text(angle = 90)) +
  scale_colour_discrete(breaks=group_order)
```

That reordered the legend but notice that it didn't reorder the groups on the x axis. If we want to reorder groups along an axis with ggplot we need to make the column with the groups into an R data type called a `factor`. Factors in R are used to specify categories.

We'll add another column called "Group_f" and make the Group into a factor and specify want order we want the levels (names of the categories).

```{r}
top10_counts <- mutate(top10_counts, Group_f=factor(Group, levels=group_order))
```

Take a look with `View()`.
```{r eval=FALSE}
View(top10_counts)
```

The Group and the Group_f column look the same but take a look by typing `top10_counts`.

```{r}
top10_counts
```

Notice that the Group column has <chr> under the heading, it is a character data type, while the Group_f column has <fct> under the heading, it is a factor data type.

We can then change our plot to use the "Group_f" column instead of Group (change `x=` and `col=`).

```{r}
ggplot(top10_counts, aes(x=Group_f, y=Norm_counts, col=Group_f)) +
  geom_jitter() +
  facet_wrap(~SYMBOL, nrow=2) +
  theme(axis.text.x = element_text(angle = 90)) 
```

Notice that the genes have also been plotted in alphabetical order. If we wanted to plot these faceted genes in the order of most signficant, then we need to make symbol column into a factor as we did for the groups.


#### Exercise

Plot the genes in order of the significance. Hint: Use mutate to add a column called SYMBOL_f containing SYMBOL as a factor with the levels in the order in `top10_syms`. Then remke the plot using SYMBOL_f in facet_wrap instead of SYMBOL.


## Creating workflows

#### Exercise
Make stripcharts of the top 10 genes in the comparison of basal cells from pregnant vs lactating mice using the file ("https://zenodo.org/record/2596382/files/limma-voom_basalpregnant-basallactate") and the `norm_counts` file from above.
